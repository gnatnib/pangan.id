// insights.ts â€” Generate data-driven insights from price data (NO AI/LLM)

import { supabase } from "./supabase";
import type { Insight, Commodity, Province } from "./types";
import { formatRupiah, formatPct, calcPctDiff } from "./utils";

/**
 * Generate all auto-insights from the latest price data.
 * All insights are generated by SQL queries and JS logic â€” no AI APIs.
 */
export async function generateInsights(): Promise<Insight[]> {
  const insights: Insight[] = [];

  try {
    // Fetch commodities and provinces for reference
    const { data: commodities } = await supabase
      .from("commodities")
      .select("*");
    const { data: provinces } = await supabase.from("provinces").select("*");

    if (!commodities || !provinces) return insights;

    const commodityMap = new Map(commodities.map((c) => [c.id, c]));
    const provinceMap = new Map(provinces.map((p) => [p.id, p]));

    // 1. Significant price increases in last 7 days
    const weeklyChanges = await getWeeklyChanges();
    for (const change of weeklyChanges.slice(0, 5)) {
      const commodity = commodityMap.get(change.commodity_id);
      if (!commodity || Math.abs(change.pct_change) < 5) continue;

      if (change.pct_change > 0) {
        insights.push({
          id: `increase-${change.commodity_id}`,
          type: "increase",
          title: `${commodity.name} naik ${Math.abs(change.pct_change).toFixed(1)}%`,
          description: `Harga rata-rata nasional ${commodity.name} naik dari ${formatRupiah(change.old_price)} menjadi ${formatRupiah(change.new_price)} dalam 7 hari terakhir.`,
          value: change.pct_change,
          unit: "%",
          commodity: commodity.name,
          commoditySlug: commodity.slug,
          icon: commodity.icon || "ðŸ“ˆ",
        });
      } else {
        insights.push({
          id: `decrease-${change.commodity_id}`,
          type: "decrease",
          title: `${commodity.name} turun ${Math.abs(change.pct_change).toFixed(1)}%`,
          description: `Harga rata-rata nasional ${commodity.name} turun dari ${formatRupiah(change.old_price)} menjadi ${formatRupiah(change.new_price)} dalam 7 hari terakhir.`,
          value: change.pct_change,
          unit: "%",
          commodity: commodity.name,
          commoditySlug: commodity.slug,
          icon: commodity.icon || "ðŸ“‰",
        });
      }
    }

    // 2. Price disparities between provinces
    const disparities = await getPriceDisparities();
    for (const disp of disparities.slice(0, 3)) {
      const commodity = commodityMap.get(disp.commodity_id);
      const cheapProv = provinceMap.get(disp.cheapest_province);
      const expProv = provinceMap.get(disp.most_expensive_province);
      if (!commodity || !cheapProv || !expProv) continue;

      insights.push({
        id: `disparity-${disp.commodity_id}`,
        type: "disparity",
        title: `${commodity.name} di ${expProv.name} ${disp.pct_diff.toFixed(0)}% lebih mahal`,
        description: `Harga ${commodity.name} di ${expProv.name} (${formatRupiah(disp.max_price)}) vs ${cheapProv.name} (${formatRupiah(disp.min_price)}). Selisih ${formatRupiah(disp.max_price - disp.min_price)}.`,
        value: disp.pct_diff,
        unit: "%",
        commodity: commodity.name,
        commoditySlug: commodity.slug,
        province: expProv.name,
        provinceSlug: expProv.slug,
        icon: "âš–ï¸",
      });
    }

    // Sort by absolute value (biggest changes first)
    insights.sort((a, b) => Math.abs(b.value) - Math.abs(a.value));
  } catch (error) {
    console.error("Error generating insights:", error);
  }

  return insights;
}

async function getWeeklyChanges() {
  // Get the latest date with data
  const { data: latestData } = await supabase
    .from("national_averages")
    .select("date")
    .eq("market_type", "traditional")
    .order("date", { ascending: false })
    .limit(1);

  if (!latestData || latestData.length === 0) return [];

  const latestDate = latestData[0].date;
  const weekAgo = new Date(latestDate);
  weekAgo.setDate(weekAgo.getDate() - 7);
  const weekAgoStr = weekAgo.toISOString().split("T")[0];

  // Get current and past averages
  const { data: current } = await supabase
    .from("national_averages")
    .select("*")
    .eq("date", latestDate)
    .eq("market_type", "traditional");

  const { data: past } = await supabase
    .from("national_averages")
    .select("*")
    .eq("date", weekAgoStr)
    .eq("market_type", "traditional");

  if (!current || !past) return [];

  const pastMap = new Map(past.map((p) => [p.commodity_id, p.avg_price]));

  return current
    .filter((c) => pastMap.has(c.commodity_id))
    .map((c) => ({
      commodity_id: c.commodity_id,
      new_price: c.avg_price,
      old_price: pastMap.get(c.commodity_id)!,
      pct_change: calcPctDiff(c.avg_price, pastMap.get(c.commodity_id)!),
    }))
    .sort((a, b) => Math.abs(b.pct_change) - Math.abs(a.pct_change));
}

async function getPriceDisparities() {
  // Get the latest date
  const { data: latestData } = await supabase
    .from("prices")
    .select("date")
    .eq("market_type", "traditional")
    .order("date", { ascending: false })
    .limit(1);

  if (!latestData || latestData.length === 0) return [];

  const latestDate = latestData[0].date;

  // Get prices per commodity per province for latest date
  const { data: prices } = await supabase
    .from("prices")
    .select("commodity_id, province_id, price")
    .eq("date", latestDate)
    .eq("market_type", "traditional")
    .gt("price", 0);

  if (!prices) return [];

  // Group by commodity
  const byCommodity = new Map<number, { province_id: string; price: number }[]>();
  for (const p of prices) {
    if (!byCommodity.has(p.commodity_id)) {
      byCommodity.set(p.commodity_id, []);
    }
    byCommodity.get(p.commodity_id)!.push({ province_id: p.province_id, price: p.price });
  }

  const disparities = [];
  for (const [commodityId, provPrices] of byCommodity) {
    if (provPrices.length < 2) continue;

    provPrices.sort((a, b) => a.price - b.price);
    const cheapest = provPrices[0];
    const mostExpensive = provPrices[provPrices.length - 1];

    const pctDiff = calcPctDiff(mostExpensive.price, cheapest.price);

    disparities.push({
      commodity_id: commodityId,
      cheapest_province: cheapest.province_id,
      most_expensive_province: mostExpensive.province_id,
      min_price: cheapest.price,
      max_price: mostExpensive.price,
      pct_diff: pctDiff,
    });
  }

  return disparities.sort((a, b) => b.pct_diff - a.pct_diff);
}
